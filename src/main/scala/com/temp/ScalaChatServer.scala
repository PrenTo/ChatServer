package com.temp

import java.net.{ServerSocket}
import java.io._
import java.util.concurrent.{ConcurrentHashMap, ExecutorService, Executors}

import scala.collection.JavaConverters._

object ScalaChatServer extends App {

  // Build Concurrent HashMap. This map is the state of all the clients and a per client message queue for messages they've produced.
  // As those messages get processed they will be removed from the message queue.
  val clientMessageState = new ConcurrentHashMap[Client, List[Message]]()

  // Initiate Executor Service
  val pool = Executors.newCachedThreadPool()

  // Create First ClientInit
  val clientInit = new ClientInit(new ServerSocket(8080), clientMessageState, pool)

  // Submit first client to pool
  pool.submit(clientInit)

  // Submit MessageHandler to pool
  pool.submit(new MessageHandler(clientMessageState))

  // Keep main thread alive
  def block(): Unit = {
    Thread.sleep(100)
    block()
  }

  block()
}

class ClientInit(
  serverSocket: ServerSocket,
  clientMessageState: ConcurrentHashMap[Client, List[Message]],
  pool: ExecutorService
) extends Runnable {
  override def run(): Unit = {
    val socket = serverSocket.accept()
    val input = socket.getInputStream
    val reader = new BufferedReader(new InputStreamReader(input))
    val output = socket.getOutputStream

    output.write("Hi! What is your name? \n".getBytes)
    val name = reader.readLine()

    output.write(s"Welcome to our chat room $name! \n".getBytes)

    val otherClients = clientMessageState.keySet().iterator().asScala.toList.map(_.name)
    output.write(s"Our chat room currently has the following people: ${otherClients.mkString} \n".getBytes)

    val client = new Client(name, reader, output, clientMessageState)
    clientMessageState.put(client, List.empty[Message])

    pool.submit(client)

    // Accept new connections by recursively invoking run()
    run()
  }
}

class Client(
  val name: String, reader: BufferedReader, val output: OutputStream, clientMessageState: ConcurrentHashMap[Client, List[Message]]
) extends Runnable {
  override def run(): Unit = {
    val message = reader.readLine()
    println(s"$name wrote $message")
    val messages = clientMessageState.getOrDefault(this, List.empty[Message])
    clientMessageState.put(this,  Message(message, name) :: messages)
    run()
  }
}

case class Message(msg: String, sender: String)

class MessageHandler(clientMessageState: ConcurrentHashMap[Client, List[Message]]) extends Runnable {
  override def run(): Unit = {
    val allClients: Set[Client] = clientMessageState.keySet().iterator.asScala.toSet
    allClients.foreach(client => {

      // For each client gets messages from the ConcurrentHashMap and for each message writes over tcp to the other clients
      clientMessageState.compute(client, (client, list) => {
        val otherClients = allClients - client // removes "current" client from set
        list.foreach(message => {
          // for each message generated by the client send to other clients
          otherClients.foreach(_.output.write(s"${message.sender}: ${message.msg} \n".getBytes))
        })

        List.empty[Message] // Resets per client message set to empty (we've processed the messages)
      })
    })

    Thread.sleep(20)
    run()
  }
}